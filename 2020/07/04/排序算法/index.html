<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>排序算法 | why_bolg</title>
  <meta name="keywords" content=" 排序 ">
  <meta name="description" content="排序算法 | why_bolg">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="1. webservice 概念WebService是一种跨编程语言和跨操作系统平台的远程调用技术。Web Service也叫XML Web Service WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是:通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。 　　XML+XSD,S">
<meta property="og:type" content="article">
<meta property="og:title" content="webservice">
<meta property="og:url" content="http://yoursite.com/2020/08/20/webservice/index.html">
<meta property="og:site_name" content="why_bolg">
<meta property="og:description" content="1. webservice 概念WebService是一种跨编程语言和跨操作系统平台的远程调用技术。Web Service也叫XML Web Service WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，轻量级的独立的通讯技术。是:通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。 　　XML+XSD,S">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-20T13:22:27.000Z">
<meta property="article:modified_time" content="2020-09-07T13:22:24.739Z">
<meta property="article:author" content="why">
<meta property="article:tag" content="java工具">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>why</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/w1041660542" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="facebook" href="https://www.facebook.com/faker.tops" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-facebook"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="instagram" href="https://www.facebook.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-instagram"></use>
                </svg>
            
        </a>
        
    
        
        <a title="reddit" href="https://www.reddit.com/user/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-reddit"></use>
                </svg>
            
        </a>
        
    
        
        <a title="weibo" href="http://weibo.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-weibo"></use>
                </svg>
            
        </a>
        
    
        
        <a title="jianshu" href="https://www.jianshu.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-jianshu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="zhihu" href="https://www.zhihu.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-zhihu"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="oschina" href="https://my.oschina.net/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-oschina"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="email" href="mailto:why199627@gmail.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1041660542&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
        
        <a title="kugou" href="https://www.kugou.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-kugou"></use>
                </svg>
            
        </a>
        
    
        
        <a title="neteasemusic" href="https://music.163.com/" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-neteasemusic"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active" data-rel="全部文章">全部文章<small>(18)</small></div></li>
    
        
            
            <li><div data-rel="数据库">数据库<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="分享">分享<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="设计模式">设计模式<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="网络">网络<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="转载">转载<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="java">java<small>(8)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="spring">spring<small>(2)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="18">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://music.163.com/">why</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>搭建博客</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>流式编程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>排序</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计模式</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>设计原则</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>网络IO</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>原创</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>注解</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTML5</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java工具</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java基础</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Oracle</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springboot</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 设计模式 "
           href="/2020/07/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="单例模式">单例模式</span>
            <span class="post-date" title="2020-07-06 15:13:47">2020/07/06</span>
        </a>
        
        <a id="top" class="全部文章 转载 "
           href="/2020/07/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"
           data-tag="排序"
           data-author="" >
            <span class="post-title" title="排序算法">排序算法</span>
            <span class="post-date" title="2020-07-04 15:13:47">2020/07/04</span>
        </a>
        
        <a id="top" class="全部文章 分享 "
           href="/2020/07/04/first_blog/"
           data-tag="搭建博客"
           data-author="" >
            <span class="post-title" title="记录搭建hexo博客遇到一些坑">记录搭建hexo博客遇到一些坑</span>
            <span class="post-date" title="2020-07-04 15:13:47">2020/07/04</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/08/20/webservice/"
           data-tag="java工具"
           data-author="" >
            <span class="post-title" title="webservice">webservice</span>
            <span class="post-date" title="2020-08-20 21:22:27">2020/08/20</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/08/15/passwordunit/"
           data-tag="java工具"
           data-author="" >
            <span class="post-title" title="PASSWORD 工具类">PASSWORD 工具类</span>
            <span class="post-date" title="2020-08-15 11:19:27">2020/08/15</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/08/15/md5/"
           data-tag="java工具"
           data-author="" >
            <span class="post-title" title="MD5 工具类">MD5 工具类</span>
            <span class="post-date" title="2020-08-15 11:13:27">2020/08/15</span>
        </a>
        
        <a  class="全部文章 spring "
           href="/2020/08/15/springboot/"
           data-tag="springboot"
           data-author="" >
            <span class="post-title" title="springboot">springboot</span>
            <span class="post-date" title="2020-08-15 11:13:27">2020/08/15</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/2020/08/04/msyql/"
           data-tag="Mysql"
           data-author="" >
            <span class="post-title" title="msyql 5.7.28安装">msyql 5.7.28安装</span>
            <span class="post-date" title="2020-08-04 22:13:47">2020/08/04</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/07/30/java%E9%9B%86%E5%90%88/"
           data-tag="java基础"
           data-author="" >
            <span class="post-title" title="java 集合">java 集合</span>
            <span class="post-date" title="2020-07-30 11:13:42">2020/07/30</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/2020/07/30/oracle%E7%AC%94%E8%AE%B0/"
           data-tag="Oracle"
           data-author="" >
            <span class="post-title" title="Oracle笔记">Oracle笔记</span>
            <span class="post-date" title="2020-07-30 11:13:42">2020/07/30</span>
        </a>
        
        <a  class="全部文章 网络 "
           href="/2020/07/18/%E7%BD%91%E7%BB%9C/"
           data-tag="网络IO"
           data-author="" >
            <span class="post-title" title="网络NIO多路复用">网络NIO多路复用</span>
            <span class="post-date" title="2020-07-18 09:13:47">2020/07/18</span>
        </a>
        
        <a  class="全部文章 "
           href="/2020/07/17/annotation/"
           data-tag="注解"
           data-author="" >
            <span class="post-title" title="注解">注解</span>
            <span class="post-date" title="2020-07-17 15:27:47">2020/07/17</span>
        </a>
        
        <a  class="全部文章 spring "
           href="/2020/07/16/webflux/"
           data-tag="流式编程"
           data-author="" >
            <span class="post-title" title="初识webflux">初识webflux</span>
            <span class="post-date" title="2020-07-16 15:13:47">2020/07/16</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/07/15/SSE/"
           data-tag="HTML5"
           data-author="" >
            <span class="post-title" title="SSE">SSE</span>
            <span class="post-date" title="2020-07-15 15:13:47">2020/07/15</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/07/09/java%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B/"
           data-tag="java基础"
           data-author="" >
            <span class="post-title" title="java的浮点类型">java的浮点类型</span>
            <span class="post-date" title="2020-07-09 14:24:47">2020/07/09</span>
        </a>
        
        <a  class="全部文章 设计模式 "
           href="/2020/07/06/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"
           data-tag="设计原则"
           data-author="" >
            <span class="post-title" title="程序开发中的7种原则简单定义">程序开发中的7种原则简单定义</span>
            <span class="post-date" title="2020-07-06 21:18:47">2020/07/06</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/07/06/java%E6%9E%9A%E4%B8%BE/"
           data-tag="原创,java基础"
           data-author="" >
            <span class="post-title" title="java枚举类">java枚举类</span>
            <span class="post-date" title="2020-07-06 21:13:47">2020/07/06</span>
        </a>
        
        <a  class="全部文章 java "
           href="/2020/07/04/thread/"
           data-tag="java多线程"
           data-author="" >
            <span class="post-title" title="多线程面试题">多线程面试题</span>
            <span class="post-date" title="2020-07-04 15:13:47">2020/07/04</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-排序算法" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">排序算法</h1>
    
    <div class="article-meta">
        
        <span class="top"><a>置顶</a></span>
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="转载">转载</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">排序</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2020-07-19 11:12:34'>2020-07-04 15:13</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2、排序算法的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-text">算法分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">算法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">3、冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）冒泡排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">（2）冒泡排序的原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">（3）动图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">4、选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）选择排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）选择排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-1"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">5、插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）插入排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）插入排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-1"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-2"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">6、归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）归并排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）归并排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-2"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-3"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">7、快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）快速排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）快速排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-3"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-4"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">8、希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）希尔排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）希尔排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-4"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-5"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">9、计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）计数排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）计数排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-5"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-6"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">10、桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）桶排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）桶排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-6"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-7"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">11、基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）基数排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）基数排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-7"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-8"><span class="toc-text">（4）代码演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">12、堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">（1）堆排序的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">（2）堆排序的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81%E5%9B%BE%E6%BC%94%E7%A4%BA-8"><span class="toc-text">（3）动态图演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-9"><span class="toc-text">（4）代码演示</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><p>​        排序算法比较基础，但是设计到很多计算机科学的想法，如下：</p>
<p>​            1、比较和非比较的策略</p>
<p>​            2、迭代和递归的实现</p>
<p>​            3、分而治之思想</p>
<p>​            4、最佳、最差、平均情况时间复杂度分析</p>
<p>​            5、随机算法</p>
<h3 id="2、排序算法的分类"><a href="#2、排序算法的分类" class="headerlink" title="2、排序算法的分类"></a>2、排序算法的分类</h3><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><p><img src="https://s1.ax1x.com/2020/07/19/URKg2R.png" alt="URKg2R.png"></p>
<h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/2.jpg" alt="2"></p>
<h3 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h3><h4 id="（1）冒泡排序的介绍"><a href="#（1）冒泡排序的介绍" class="headerlink" title="（1）冒泡排序的介绍"></a>（1）冒泡排序的介绍</h4><p>​        冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h4 id="（2）冒泡排序的原理："><a href="#（2）冒泡排序的原理：" class="headerlink" title="（2）冒泡排序的原理："></a>（2）冒泡排序的原理：</h4><p>​        1、如果元素大小关系不正确，交换这两个数（在本例中为a&gt; b），</p>
<p>​        2、比较一对相邻元素（a，b），</p>
<p>​        3、重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）</p>
<p>​        4、到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1。</p>
<h4 id="（3）动图演示"><a href="#（3）动图演示" class="headerlink" title="（3）动图演示"></a>（3）动图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/3.jpg" alt="3"></p>
<h4 id="（4）代码演示"><a href="#（4）代码演示" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">public static void bubbleSort(int array[]) &#123;
        int t = 0;
        for (int i = 0; i &lt; array.length - 1; i++)&#123;
            for (int j = 0; j &lt; array.length - 1 - i; j++)&#123;
                if (array[j] &gt; array[j + 1]) &#123;
                    t = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = t;
                &#125;
            &#125;
        &#125;
    &#125;</code></pre>
<h3 id="4、选择排序"><a href="#4、选择排序" class="headerlink" title="4、选择排序"></a>4、选择排序</h3><h4 id="（1）选择排序的介绍"><a href="#（1）选择排序的介绍" class="headerlink" title="（1）选择排序的介绍"></a>（1）选择排序的介绍</h4><p>​        选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="（2）选择排序的原理"><a href="#（2）选择排序的原理" class="headerlink" title="（2）选择排序的原理"></a>（2）选择排序的原理</h4><p>​        1、在 <strong>[L … N-1]</strong> 范围内找出最小项目 <strong>X</strong> 的位置，</p>
<p>​        2、用第 <strong>L</strong> 项交换X，</p>
<p>​        3、将下限 <strong>L</strong> 增加1并重复步骤1直到 <strong>L = N-2</strong>。</p>
<h4 id="（3）动态图演示"><a href="#（3）动态图演示" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/4.jpg" alt="4"></p>
<h4 id="（4）代码演示-1"><a href="#（4）代码演示-1" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">public static void selectionSort(int[] array) &#123;
        for (int i = 0; i &lt; array.length; i++) &#123;
            int index = i;
            for (int j = i; j &lt; array.length; j++) &#123;
                if (array[j] &lt; array[index]) 
                    index = j; 
            &#125;
            int temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        &#125;
    &#125;</code></pre>
<h3 id="5、插入排序"><a href="#5、插入排序" class="headerlink" title="5、插入排序"></a>5、插入排序</h3><h4 id="（1）插入排序的介绍"><a href="#（1）插入排序的介绍" class="headerlink" title="（1）插入排序的介绍"></a>（1）插入排序的介绍</h4><p>​        插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<h4 id="（2）插入排序的原理"><a href="#（2）插入排序的原理" class="headerlink" title="（2）插入排序的原理"></a>（2）插入排序的原理</h4><p>​        1、从第一个元素开始，该元素可以认为已经被排序；</p>
<p>​        2、取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
<p>​        3、如果该元素（已排序）大于新元素，将该元素移到下一位置；</p>
<p>​        4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p>
<p>​        5、将新元素插入到该位置后；</p>
<p>​        6、重复步骤2~5。</p>
<h4 id="（3）动态图演示-1"><a href="#（3）动态图演示-1" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/5.jpg" alt="img"></p>
<h4 id="（4）代码演示-2"><a href="#（4）代码演示-2" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">public static void insertionSort(int[] array) &#123;
        int current;
        for (int i = 0; i &lt; array.length - 1; i++) &#123;
            current = array[i + 1];
            int preIndex = i;
            while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) &#123;
                array[preIndex + 1] = array[preIndex];
                preIndex--;
            &#125;
            array[preIndex + 1] = current;
        &#125;
    &#125;</code></pre>
<h3 id="6、归并排序"><a href="#6、归并排序" class="headerlink" title="6、归并排序"></a>6、归并排序</h3><h4 id="（1）归并排序的介绍"><a href="#（1）归并排序的介绍" class="headerlink" title="（1）归并排序的介绍"></a>（1）归并排序的介绍</h4><p>​        归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h4 id="（2）归并排序的原理"><a href="#（2）归并排序的原理" class="headerlink" title="（2）归并排序的原理"></a>（2）归并排序的原理</h4><p>​        1、将每对单个元素（默认情况下，已排序）归并为2个元素的有序数组，</p>
<p>​        2、将2个元素的每对有序数组归并成4个元素的有序数组，重复这个过程……，</p>
<p>​        3、最后一步：归并2个N / 2元素的排序数组（为了简化讨论，我们假设N是偶数）以获得完全排序的N个元素数组。</p>
<h4 id="（3）动态图演示-2"><a href="#（3）动态图演示-2" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/6.jpg" alt="img"></p>
<h4 id="（4）代码演示-3"><a href="#（4）代码演示-3" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">    public static int[] MergeSort(int[] array) &#123;
        if (array.length &lt; 2) return array;
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
        return merge(MergeSort(left), MergeSort(right));
    &#125;

    public static int[] merge(int[] left, int[] right) &#123;
        int[] result = new int[left.length + right.length];
        for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) &#123;
            if (i &gt;= left.length)
                result[index] = right[j++];
            else if (j &gt;= right.length)
                result[index] = left[i++];
            else if (left[i] &gt; right[j])
                result[index] = right[j++];
            else
                result[index] = left[i++];
        &#125;
        return result;
    &#125;</code></pre>
<h3 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h3><h4 id="（1）快速排序的介绍"><a href="#（1）快速排序的介绍" class="headerlink" title="（1）快速排序的介绍"></a>（1）快速排序的介绍</h4><p>​        快速排序（Quicksort）是对冒泡排序的一种改进。</p>
<p>​        它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<h4 id="（2）快速排序的原理"><a href="#（2）快速排序的原理" class="headerlink" title="（2）快速排序的原理"></a>（2）快速排序的原理</h4><p>​        1、从数列中挑出一个元素，称为 “基准”（pivot）；<br>​        2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>​        3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<h4 id="（3）动态图演示-3"><a href="#（3）动态图演示-3" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/7.jpg" alt="img"></p>
<h4 id="（4）代码演示-4"><a href="#（4）代码演示-4" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">/**
     * 快速排序方法
     * @param array
     * @param start
     * @param end
     * @return
     */
    public static int[] QuickSort(int[] array, int start, int end) &#123;
        if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;
        int smallIndex = partition(array, start, end);
        if (smallIndex &gt; start)
            QuickSort(array, start, smallIndex - 1);
        if (smallIndex &lt; end)
            QuickSort(array, smallIndex + 1, end);
        return array;
    &#125;
    /**
     * 快速排序算法——partition
     * @param array
     * @param start
     * @param end
     * @return
     */
    public static int partition(int[] array, int start, int end) &#123;
        int pivot = (int) (start + Math.random() * (end - start + 1));
        int smallIndex = start - 1;
        swap(array, pivot, end);
        for (int i = start; i &lt;= end; i++)
            if (array[i] &lt;= array[end]) &#123;
                smallIndex++;
                if (i &gt; smallIndex)
                    swap(array, i, smallIndex);
            &#125;
        return smallIndex;
    &#125;

    /**
     * 交换数组内两个元素
     * @param array
     * @param i
     * @param j
     */
    public static void swap(int[] array, int i, int j) &#123;
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    &#125;</code></pre>
<h3 id="8、希尔排序"><a href="#8、希尔排序" class="headerlink" title="8、希尔排序"></a>8、希尔排序</h3><h4 id="（1）希尔排序的介绍"><a href="#（1）希尔排序的介绍" class="headerlink" title="（1）希尔排序的介绍"></a>（1）希尔排序的介绍</h4><p>​        希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。</p>
<p>​        希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="（2）希尔排序的原理"><a href="#（2）希尔排序的原理" class="headerlink" title="（2）希尔排序的原理"></a>（2）希尔排序的原理</h4><p>​        1、选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>​        2、按增量序列个数k，对序列进行k 趟排序；<br>​        3、每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h4 id="（3）动态图演示-4"><a href="#（3）动态图演示-4" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/8.jpg" alt="img"></p>
<h4 id="（4）代码演示-5"><a href="#（4）代码演示-5" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">    /**
     * 希尔排序
     *
     * @param array
     * @return
     */
    public static int[] ShellSort(int[] array) &#123;
        int len = array.length;
        int temp, gap = len / 2;
        while (gap &gt; 0) &#123;
            for (int i = gap; i &lt; len; i++) &#123;
                temp = array[i];
                int preIndex = i - gap;
                while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123;
                    array[preIndex + gap] = array[preIndex];
                    preIndex -= gap;
                &#125;
                array[preIndex + gap] = temp;
            &#125;
            gap /= 2;
        &#125;
        return array;
    &#125;</code></pre>
<h3 id="9、计数排序"><a href="#9、计数排序" class="headerlink" title="9、计数排序"></a>9、计数排序</h3><h4 id="（1）计数排序的介绍"><a href="#（1）计数排序的介绍" class="headerlink" title="（1）计数排序的介绍"></a>（1）计数排序的介绍</h4><p>​        计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>​        计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="（2）计数排序的原理"><a href="#（2）计数排序的原理" class="headerlink" title="（2）计数排序的原理"></a>（2）计数排序的原理</h4><p>​        1、找出待排序的数组中最大和最小的元素；<br>​        2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>​        3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>​        4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<h4 id="（3）动态图演示-5"><a href="#（3）动态图演示-5" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/9.jpg" alt="img"></p>
<h4 id="（4）代码演示-6"><a href="#（4）代码演示-6" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">    /**
     * 计数排序
     *
     * @param array
     * @return
     */
    public static int[] CountingSort(int[] array) &#123;
        if (array.length == 0) return array;
        int bias, min = array[0], max = array[0];
        for (int i = 1; i &lt; array.length; i++) &#123;
            if (array[i] &gt; max)
                max = array[i];
            if (array[i] &lt; min)
                min = array[i];
        &#125;
        bias = 0 - min;
        int[] bucket = new int[max - min + 1];
        Arrays.fill(bucket, 0);
        for (int i = 0; i &lt; array.length; i++) &#123;
            bucket[array[i] + bias]++;
        &#125;
        int index = 0, i = 0;
        while (index &lt; array.length) &#123;
            if (bucket[i] != 0) &#123;
                array[index] = i - bias;
                bucket[i]--;
                index++;
            &#125; else
                i++;
        &#125;
        return array;
    &#125;</code></pre>
<h3 id="10、桶排序"><a href="#10、桶排序" class="headerlink" title="10、桶排序"></a>10、桶排序</h3><h4 id="（1）桶排序的介绍"><a href="#（1）桶排序的介绍" class="headerlink" title="（1）桶排序的介绍"></a>（1）桶排序的介绍</h4><p>​        桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p>
<h4 id="（2）桶排序的原理"><a href="#（2）桶排序的原理" class="headerlink" title="（2）桶排序的原理"></a>（2）桶排序的原理</h4><p>​        1、设置一个定量的数组当作空桶；<br>​        2、遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>​        3、对每个不是空的桶进行排序；<br>​        4、从不是空的桶里把排好序的数据拼接起来。 </p>
<h4 id="（3）动态图演示-6"><a href="#（3）动态图演示-6" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/10.jpg"></p>
<h4 id="（4）代码演示-7"><a href="#（4）代码演示-7" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">    /**
     * 桶排序
     * 
     * @param array
     * @param bucketSize
     * @return
     */
    public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) &#123;
        if (array == null || array.size() &lt; 2)
            return array;
        int max = array.get(0), min = array.get(0);
        // 找到最大值最小值
        for (int i = 0; i &lt; array.size(); i++) &#123;
            if (array.get(i) &gt; max)
                max = array.get(i);
            if (array.get(i) &lt; min)
                min = array.get(i);
        &#125;
        int bucketCount = (max - min) / bucketSize + 1;
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);
        ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; bucketCount; i++) &#123;
            bucketArr.add(new ArrayList&lt;Integer&gt;());
        &#125;
        for (int i = 0; i &lt; array.size(); i++) &#123;
            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));
        &#125;
        for (int i = 0; i &lt; bucketCount; i++) &#123;
            if (bucketSize == 1) &#123; // 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误
                for (int j = 0; j &lt; bucketArr.get(i).size(); j++)
                    resultArr.add(bucketArr.get(i).get(j));
            &#125; else &#123;
                if (bucketCount == 1)
                    bucketSize--;
                ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);
                for (int j = 0; j &lt; temp.size(); j++)
                    resultArr.add(temp.get(j));
            &#125;
        &#125;
        return resultArr;
    &#125;</code></pre>
<h3 id="11、基数排序"><a href="#11、基数排序" class="headerlink" title="11、基数排序"></a>11、基数排序</h3><h4 id="（1）基数排序的介绍"><a href="#（1）基数排序的介绍" class="headerlink" title="（1）基数排序的介绍"></a>（1）基数排序的介绍</h4><p>​        基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>​        基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的</p>
<h4 id="（2）基数排序的原理"><a href="#（2）基数排序的原理" class="headerlink" title="（2）基数排序的原理"></a>（2）基数排序的原理</h4><p>​        1、取得数组中的最大数，并取得位数；<br>​        2、arr为原始数组，从最低位开始取每个位组成radix数组；<br>​        3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h4 id="（3）动态图演示-7"><a href="#（3）动态图演示-7" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/11.jpg" alt="img"></p>
<h4 id="（4）代码演示-8"><a href="#（4）代码演示-8" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">    /**
     * 基数排序
     * @param array
     * @return
     */
    public static int[] RadixSort(int[] array) &#123;
        if (array == null || array.length &lt; 2)
            return array;
        // 1.先算出最大数的位数；
        int max = array[0];
        for (int i = 1; i &lt; array.length; i++) &#123;
            max = Math.max(max, array[i]);
        &#125;
        int maxDigit = 0;
        while (max != 0) &#123;
            max /= 10;
            maxDigit++;
        &#125;
        int mod = 10, div = 1;
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        for (int i = 0; i &lt; 10; i++)
            bucketList.add(new ArrayList&lt;Integer&gt;());
        for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123;
            for (int j = 0; j &lt; array.length; j++) &#123;
                int num = (array[j] % mod) / div;
                bucketList.get(num).add(array[j]);
            &#125;
            int index = 0;
            for (int j = 0; j &lt; bucketList.size(); j++) &#123;
                for (int k = 0; k &lt; bucketList.get(j).size(); k++)
                    array[index++] = bucketList.get(j).get(k);
                bucketList.get(j).clear();
            &#125;
        &#125;
        return array;
    &#125;</code></pre>
<h3 id="12、堆排序"><a href="#12、堆排序" class="headerlink" title="12、堆排序"></a>12、堆排序</h3><h4 id="（1）堆排序的介绍"><a href="#（1）堆排序的介绍" class="headerlink" title="（1）堆排序的介绍"></a>（1）堆排序的介绍</h4><p>​        堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h4 id="（2）堆排序的原理"><a href="#（2）堆排序的原理" class="headerlink" title="（2）堆排序的原理"></a>（2）堆排序的原理</h4><p>​        1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>​        2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>​        3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
<h4 id="（3）动态图演示-8"><a href="#（3）动态图演示-8" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://github.com/msbbigdata/javase/blob/master/image/12.jpg" alt="img"></p>
<h4 id="（4）代码演示-9"><a href="#（4）代码演示-9" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre><code class="java">//声明全局变量，用于记录数组array的长度；
static int len;
    /**
     * 堆排序算法
     *
     * @param array
     * @return
     */
    public static int[] HeapSort(int[] array) &#123;
        len = array.length;
        if (len &lt; 1) return array;
        //1.构建一个最大堆
        buildMaxHeap(array);
        //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆
        while (len &gt; 0) &#123;
            swap(array, 0, len - 1);
            len--;
            adjustHeap(array, 0);
        &#125;
        return array;
    &#125;
    /**
     * 建立最大堆
     *
     * @param array
     */
    public static void buildMaxHeap(int[] array) &#123;
        //从最后一个非叶子节点开始向上构造最大堆
        for (int i = (len/2 - 1); i &gt;= 0; i--) &#123; //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) 
            adjustHeap(array, i);
        &#125;
    &#125;
    /**
     * 调整使之成为最大堆
     *
     * @param array
     * @param i
     */
    public static void adjustHeap(int[] array, int i) &#123;
        int maxIndex = i;
        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树
        if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])
            maxIndex = i * 2;
        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树
        if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])
            maxIndex = i * 2 + 1;
        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。
        if (maxIndex != i) &#123;
            swap(array, maxIndex, i);
            adjustHeap(array, maxIndex);
        &#125;
    &#125;</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 why199627@gmail.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '48ce11548f6c8568b353',
            clientSecret: '487c8c90625f53defe6801c44a915c14a0a77c5f',
            repo: 'w1041660542.github.io',
            owner: 'w1041660542',
            admin: ['w1041660542'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2020 @why
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
